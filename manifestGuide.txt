We have created a Chat Server that can handle multiple clients over an internet connection. These clients communicate with the server and accept basic commands that allow for client modifications and personalizations. Beginning with the protocol module, we have the handling for the encoding and decoding of the JSON objects. This is how all of the communication between the client and the server is actually received and sent between each other. This module converts JSON strings to Python modules and vice versa. Objects are sent over sockets, converted into strings, encoded, retrieved from the socket, decoded, and then checked for any whitespaces before or after the data. The line of text is then received over a socket and converted into a Python object. This is how the clients can communicate with the server.

The chat server handles any and all clients (and their messages) that connect over the network. We first import the sendObject and receiveObject functions from our protocol so that the encoded and decoded data can be sent and received. We also used the socket, threading, and argparse modules to handle the communication over the network connection, allow for multiple channels and servers to connect, and to handle the arguments being passed with each command, respectively. We then included the time module to handle the time out after idling feature and the period of rest for the server. The chat server communication begins with a function aptly named, ChatServer. This function begins by intitializing the variables that will be used throughout the connection so that varying functions (i.e. connecting to a port, setting the debug level, storing chosen nicknames, etc) can operate at the highest level. We included a logging function so that the server messages and user activity could be logged. The server is started by creating a TCP socket that is binded to all interfaces on the specific port. The socket is then able to listen for any incoming connections from clients. This function checks for any idleness of the server over three minutes, makes sure there are no more than four threads connected at once, and shows the logging message that is sent once a client is successfully connected. It also shows the message that is sent if the user presses ctrl-c. The function for handling client connections initalizes with the client not yet having a nickname or having joined a channel. We then receive the user's keyboard input as an object over the socket that is interpreted as one of the many commands that will be listed below. If the connection is severed or the user disconnects, the cleanup process begins where all of the user information is cleaned out to prevent against server corruption. The processingCommands function includes conditional statements for all of the possible user commands. Each of the commands has a function that sends objects over the socket based on what the user is entering. We have a tellAll function so that the server can share messages to all clients within a certain channel when changes are made. This includes users joining and joining the channel. The main function handles the very beginning of connection to the server and allows for the reading of arguments that are trying to parsed during connection attempts.

The chat client also imports the send and receive objects from the protocol module so that the messages being sent from the clients can be encoded and decoded. We also have the same socket and threading modules being utilized, along with MIMEText being imported from email.mime.text. This module is important for the specific formatting that our messages will have once they are sent and received. The ChatClient class begins with an initialization of no network connection and no nickname having been set yet. Our clientConnection class is where the actual attempt at connecting over the network with a socket will begin. The client creates a socket object at a specific IPv4 address and TCP connection in order to offer a connection to a host and port. Once connected, a new thread object begins listening on a loop for any incoming messages to the client from the server. We make sure to provide exception error messages for the chance of a client or server suddenly disconnecting. The listener that is looping continuously, first receives an object from the server over the network socket. This message is then printed out for the user to see. The inputCommandsLoop is where all of the possible user commands are handled on the client side. This loop begins by prompting the user to enter a command and provides the declarations that are applicable for each valid command. For the connect, nick, join, and leave commands, the user must enter more than just the command itself. There will be whitespaces to account for because of multiple words being read by the client and sent to the server. This means that the text must be split into multiple parts, for connect, three parts, and for nick, join, and leave, two parts. Each part will be taken as an object to be interpreted by the server and moved through the necessary protocol, going from a string to a JSON object. The help command shows all of the available valid commands that a user can enter and an exception in case the user enters a command that is not valid. The main block then calls the ChatClient and inputCommandsLoop to begin the client connection and prompts. 
